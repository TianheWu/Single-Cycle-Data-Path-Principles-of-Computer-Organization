ori $1,0x1010            #测试ori，向$1中写入0x1010
ori $2,0x0101            #测试ori，向$2中写入0x0101

ori $3,10                #给$3赋值为10
ori $4,100               #给$4赋值为100
ori $5,10                #给$5赋值为10

addu $20,$20,$3          #测addu $20=10
addu $21,$21,$4          #测addu $21=100

beq $3,$5,then           #测试beq会成功跳转时的情况
circle1:
addu $6,$6,$3            #$6永远为0
j end                    #不会走这个j指令

then:                    #通过beq执行then标号下指令
sw $3,4($0)              #测试sw，将$3处的值写入数据存储器地址为4的地方，值为10
sw $4,12($0)             #测试sw，将$4处的值写入数据存储器地址为12的地方，值为100

end:
subu $4,$4,$3            #测试subu指令，令$4内的值100不断减$3内的值10
beq $3,$4,circle2        #测试beq不跳转的情况，进入PC+4
j end                    #测试j指令

circle2:
subu $21,$21,$20         #测试subu指令$21内的值100减$20内的值10
subu $21,$21,$20         #测试subu指令$21内的值100减$20内的值10
lw $15,4($0)             #测试lw指令，从4位置处取出刚才存的值10，赋值给寄存器$15
lw $16,12($0)            #测试lw指令，从4位置处取出刚才存的值100，赋值给寄存器$16

ori $17,0x1111           #给寄存器$17低位赋值0x1111
ori $18,0xabcd           #给寄存器$18低位赋值0xabcd
lui $17,0xabab           #测试lui指令，给寄存器$17的高位赋值abab，低位清0
lui $18,0xcdcd           #测试lui指令，给寄存器$18的高位赋值cdcd，低位清0
